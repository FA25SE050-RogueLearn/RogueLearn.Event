// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRoomPlayerScore = `-- name: AddRoomPlayerScore :exec
UPDATE public.room_players
SET score = score + $1::integer
WHERE room_id = $2 AND user_id = $3
`

type AddRoomPlayerScoreParams struct {
	PointsToAdd int32
	RoomID      pgtype.UUID
	UserID      pgtype.UUID
}

func (q *Queries) AddRoomPlayerScore(ctx context.Context, arg AddRoomPlayerScoreParams) error {
	_, err := q.db.Exec(ctx, addRoomPlayerScore, arg.PointsToAdd, arg.RoomID, arg.UserID)
	return err
}

const assignGuildToRoom = `-- name: AssignGuildToRoom :exec
UPDATE event_guild_participants
SET room_id = $3
WHERE event_id = $1 AND guild_id = $2
`

type AssignGuildToRoomParams struct {
	EventID pgtype.UUID
	GuildID pgtype.UUID
	RoomID  pgtype.UUID
}

func (q *Queries) AssignGuildToRoom(ctx context.Context, arg AssignGuildToRoomParams) error {
	_, err := q.db.Exec(ctx, assignGuildToRoom, arg.EventID, arg.GuildID, arg.RoomID)
	return err
}

const calculateGuildLeaderboard = `-- name: CalculateGuildLeaderboard :exec
WITH latest_snapshot_time AS (
  SELECT MAX(gle1.snapshot_date) as snapshot_time
  FROM guild_leaderboard_entries gle1
  WHERE gle1.event_id = $1
),
ranked_entries AS (
  SELECT
    id,
    DENSE_RANK() OVER (ORDER BY total_score DESC) as new_rank
  FROM guild_leaderboard_entries gle2
  WHERE gle2.event_id = $1 AND gle2.snapshot_date = (SELECT gle3.snapshot_time FROM latest_snapshot_time gle3)
)
UPDATE guild_leaderboard_entries gle
SET rank = re.new_rank
FROM ranked_entries re
WHERE gle.id = re.id
`

func (q *Queries) CalculateGuildLeaderboard(ctx context.Context, eventID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, calculateGuildLeaderboard, eventID)
	return err
}

const calculateRoomLeaderboard = `-- name: CalculateRoomLeaderboard :exec
WITH locked_players AS (
  -- First, lock the rows without window functions
  SELECT user_id, score, joined_at
  FROM room_players
  WHERE room_id = $1
  FOR UPDATE  -- Lock these rows to prevent concurrent modifications
),
ranked_players AS (
  -- Then, calculate rankings using window function (no FOR UPDATE here)
  SELECT
    user_id,
    DENSE_RANK() OVER (ORDER BY score DESC, joined_at ASC) as new_place
  FROM locked_players
)
UPDATE room_players rp
SET place = rp_ranked.new_place
FROM ranked_players rp_ranked
WHERE rp.room_id = $1 AND rp.user_id = rp_ranked.user_id
`

// This query uses SELECT FOR UPDATE to lock rows and prevent race conditions
// across multiple instances when calculating leaderboard rankings.
// The lock is held until the transaction commits, ensuring atomicity.
func (q *Queries) CalculateRoomLeaderboard(ctx context.Context, roomID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, calculateRoomLeaderboard, roomID)
	return err
}

const captureFinalGuildLeaderboard = `-- name: CaptureFinalGuildLeaderboard :exec
WITH guild_scores AS (
  SELECT
    rp.guild_id,
    SUM(rp.score) as total_score,
    COUNT(DISTINCT rp.user_id) as player_count
  FROM room_players rp
  INNER JOIN rooms r ON rp.room_id = r.id
  WHERE r.event_id = $1
    AND rp.state IN ('completed'::room_player_state, 'present'::room_player_state)
  GROUP BY rp.guild_id
),
ranked_guilds AS (
  SELECT
    guild_id,
    total_score,
    DENSE_RANK() OVER (ORDER BY total_score DESC) as rank
  FROM guild_scores
)
INSERT INTO guild_leaderboard_entries (guild_id, guild_name, event_id, rank, total_score, snapshot_date)
SELECT
  rg.guild_id,
  'Guild-' || rg.guild_id::text as guild_name,  -- TODO: Get actual guild name from guild service
  $1::uuid as event_id,
  rg.rank::integer,
  rg.total_score::integer,
  NOW() AT TIME ZONE 'utc' as snapshot_date
FROM ranked_guilds rg
`

// Capture final guild leaderboard snapshot for an event
// Calculates total scores by summing all players from each guild
// Creates permanent record of which guild won
func (q *Queries) CaptureFinalGuildLeaderboard(ctx context.Context, dollar_1 pgtype.UUID) error {
	_, err := q.db.Exec(ctx, captureFinalGuildLeaderboard, dollar_1)
	return err
}

const captureFinalRoomLeaderboards = `-- name: CaptureFinalRoomLeaderboards :exec
INSERT INTO leaderboard_entries (user_id, username, event_id, rank, score, snapshot_date)
SELECT
  rp.user_id,
  rp.username,
  $1::uuid as event_id,
  rp.place as rank,
  rp.score,
  NOW() AT TIME ZONE 'utc' as snapshot_date
FROM room_players rp
INNER JOIN rooms r ON rp.room_id = r.id
WHERE r.event_id = $1
  AND rp.state IN ('completed'::room_player_state, 'present'::room_player_state)
ORDER BY rp.score DESC, rp.joined_at ASC
`

// Capture final leaderboard snapshot for all rooms in an event
// This creates a permanent historical record of final rankings and scores
// Called when event completes to preserve winner information
func (q *Queries) CaptureFinalRoomLeaderboards(ctx context.Context, dollar_1 pgtype.UUID) error {
	_, err := q.db.Exec(ctx, captureFinalRoomLeaderboards, dollar_1)
	return err
}

const checkIfProblemAlreadySolved = `-- name: CheckIfProblemAlreadySolved :one
SELECT id, status, submitted_at
FROM submissions
WHERE user_id = $1
  AND code_problem_id = $2
  AND room_id = $3
  AND status = 'accepted'
LIMIT 1
`

type CheckIfProblemAlreadySolvedParams struct {
	UserID        pgtype.UUID
	CodeProblemID pgtype.UUID
	RoomID        pgtype.UUID
}

type CheckIfProblemAlreadySolvedRow struct {
	ID          pgtype.UUID
	Status      SubmissionStatus
	SubmittedAt pgtype.Timestamptz
}

// Check if a player has already solved a problem in a specific room
// Returns the submission if it exists and is accepted, otherwise returns error
func (q *Queries) CheckIfProblemAlreadySolved(ctx context.Context, arg CheckIfProblemAlreadySolvedParams) (CheckIfProblemAlreadySolvedRow, error) {
	row := q.db.QueryRow(ctx, checkIfProblemAlreadySolved, arg.UserID, arg.CodeProblemID, arg.RoomID)
	var i CheckIfProblemAlreadySolvedRow
	err := row.Scan(&i.ID, &i.Status, &i.SubmittedAt)
	return i, err
}

const countCodeProblems = `-- name: CountCodeProblems :one
SELECT COUNT(*) FROM code_problems
`

func (q *Queries) CountCodeProblems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCodeProblems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventParticipants = `-- name: CountEventParticipants :one
SELECT COUNT(*) FROM event_guild_participants
WHERE event_id = $1
`

func (q *Queries) CountEventParticipants(ctx context.Context, eventID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEventParticipants, eventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventRequests = `-- name: CountEventRequests :one
SELECT COUNT(*) FROM event_requests
`

func (q *Queries) CountEventRequests(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEventRequests)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventRequestsByGuild = `-- name: CountEventRequestsByGuild :one
SELECT COUNT(*) FROM event_requests
WHERE requester_guild_id = $1
`

func (q *Queries) CountEventRequestsByGuild(ctx context.Context, requesterGuildID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEventRequestsByGuild, requesterGuildID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventRequestsByStatus = `-- name: CountEventRequestsByStatus :one
SELECT COUNT(*) FROM event_requests
WHERE status = $1
`

func (q *Queries) CountEventRequestsByStatus(ctx context.Context, status EventRequestStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countEventRequestsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*) FROM events
`

func (q *Queries) CountEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByStatus = `-- name: CountEventsByStatus :one
SELECT COUNT(*) FROM events
WHERE status = $1
`

// Count events filtered by status
func (q *Queries) CountEventsByStatus(ctx context.Context, status EventStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubmissionsByUser = `-- name: CountSubmissionsByUser :one
SELECT COUNT(*)
FROM submissions s
WHERE s.user_id = $1
`

func (q *Queries) CountSubmissionsByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissionsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCodeProblem = `-- name: CreateCodeProblem :one
INSERT INTO code_problems (title, problem_statement, difficulty)
VALUES ($1, $2, $3)
RETURNING id, title, problem_statement, difficulty, created_at
`

type CreateCodeProblemParams struct {
	Title            string
	ProblemStatement string
	Difficulty       int32
}

// Code Problems
func (q *Queries) CreateCodeProblem(ctx context.Context, arg CreateCodeProblemParams) (CodeProblem, error) {
	row := q.db.QueryRow(ctx, createCodeProblem, arg.Title, arg.ProblemStatement, arg.Difficulty)
	var i CodeProblem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ProblemStatement,
		&i.Difficulty,
		&i.CreatedAt,
	)
	return i, err
}

const createCodeProblemLanguageDetail = `-- name: CreateCodeProblemLanguageDetail :one
INSERT INTO code_problem_language_details (code_problem_id, language_id, solution_stub, driver_code, time_constraint_ms, space_constraint_mb)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING code_problem_id, language_id, solution_stub, driver_code, time_constraint_ms, space_constraint_mb
`

type CreateCodeProblemLanguageDetailParams struct {
	CodeProblemID     pgtype.UUID
	LanguageID        pgtype.UUID
	SolutionStub      string
	DriverCode        string
	TimeConstraintMs  int32
	SpaceConstraintMb int32
}

// Code Problem Language Details
func (q *Queries) CreateCodeProblemLanguageDetail(ctx context.Context, arg CreateCodeProblemLanguageDetailParams) (CodeProblemLanguageDetail, error) {
	row := q.db.QueryRow(ctx, createCodeProblemLanguageDetail,
		arg.CodeProblemID,
		arg.LanguageID,
		arg.SolutionStub,
		arg.DriverCode,
		arg.TimeConstraintMs,
		arg.SpaceConstraintMb,
	)
	var i CodeProblemLanguageDetail
	err := row.Scan(
		&i.CodeProblemID,
		&i.LanguageID,
		&i.SolutionStub,
		&i.DriverCode,
		&i.TimeConstraintMs,
		&i.SpaceConstraintMb,
	)
	return i, err
}

const createCodeProblemTag = `-- name: CreateCodeProblemTag :exec
INSERT INTO code_problem_tags (code_problem_id, tag_id)
VALUES ($1, $2)
`

type CreateCodeProblemTagParams struct {
	CodeProblemID pgtype.UUID
	TagID         pgtype.UUID
}

// Code Problem Tags
func (q *Queries) CreateCodeProblemTag(ctx context.Context, arg CreateCodeProblemTagParams) error {
	_, err := q.db.Exec(ctx, createCodeProblemTag, arg.CodeProblemID, arg.TagID)
	return err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
  title,
  description,
  type,
  started_date,
  end_date,
  max_guilds,
  max_players_per_guild,
  number_of_rooms,
  guilds_per_room,
  room_naming_prefix,
  original_request_id,
  status,
  assignment_date
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date
`

type CreateEventParams struct {
	Title              string
	Description        string
	Type               EventType
	StartedDate        pgtype.Timestamptz
	EndDate            pgtype.Timestamptz
	MaxGuilds          pgtype.Int4
	MaxPlayersPerGuild pgtype.Int4
	NumberOfRooms      pgtype.Int4
	GuildsPerRoom      pgtype.Int4
	RoomNamingPrefix   pgtype.Text
	OriginalRequestID  pgtype.UUID
	Status             EventStatus
	AssignmentDate     pgtype.Timestamptz
}

// Events
func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.StartedDate,
		arg.EndDate,
		arg.MaxGuilds,
		arg.MaxPlayersPerGuild,
		arg.NumberOfRooms,
		arg.GuildsPerRoom,
		arg.RoomNamingPrefix,
		arg.OriginalRequestID,
		arg.Status,
		arg.AssignmentDate,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartedDate,
		&i.EndDate,
		&i.MaxGuilds,
		&i.MaxPlayersPerGuild,
		&i.NumberOfRooms,
		&i.GuildsPerRoom,
		&i.RoomNamingPrefix,
		&i.OriginalRequestID,
		&i.Status,
		&i.AssignmentDate,
	)
	return i, err
}

const createEventCodeProblem = `-- name: CreateEventCodeProblem :exec
INSERT INTO event_code_problems (event_id, code_problem_id, score)
VALUES ($1, $2, $3)
`

type CreateEventCodeProblemParams struct {
	EventID       pgtype.UUID
	CodeProblemID pgtype.UUID
	Score         int32
}

// Event Code Problems
func (q *Queries) CreateEventCodeProblem(ctx context.Context, arg CreateEventCodeProblemParams) error {
	_, err := q.db.Exec(ctx, createEventCodeProblem, arg.EventID, arg.CodeProblemID, arg.Score)
	return err
}

const createEventGuildParticipant = `-- name: CreateEventGuildParticipant :one
INSERT INTO event_guild_participants (event_id, guild_id, room_id)
VALUES ($1, $2, $3)
RETURNING event_id, guild_id, joined_at, room_id
`

type CreateEventGuildParticipantParams struct {
	EventID pgtype.UUID
	GuildID pgtype.UUID
	RoomID  pgtype.UUID
}

// Event Guild Participants
func (q *Queries) CreateEventGuildParticipant(ctx context.Context, arg CreateEventGuildParticipantParams) (EventGuildParticipant, error) {
	row := q.db.QueryRow(ctx, createEventGuildParticipant, arg.EventID, arg.GuildID, arg.RoomID)
	var i EventGuildParticipant
	err := row.Scan(
		&i.EventID,
		&i.GuildID,
		&i.JoinedAt,
		&i.RoomID,
	)
	return i, err
}

const createEventRequest = `-- name: CreateEventRequest :one
INSERT INTO event_requests (
  requester_guild_id, event_type, title, description,
  proposed_start_date, proposed_end_date, notes,
  participation_details, room_configuration, event_specifics
) VALUES (
  $1, $2, $3, $4, $5, $6, $7,
  $8::jsonb,
  $9::jsonb,
  $10::jsonb
) RETURNING id, status, requester_guild_id, processed_by_admin_id, created_at, processed_at, event_type, title, description, proposed_start_date, proposed_end_date, notes, participation_details, room_configuration, event_specifics, rejection_reason, approved_event_id
`

type CreateEventRequestParams struct {
	RequesterGuildID     pgtype.UUID
	EventType            EventType
	Title                string
	Description          string
	ProposedStartDate    pgtype.Timestamptz
	ProposedEndDate      pgtype.Timestamptz
	Notes                pgtype.Text
	ParticipationDetails string
	RoomConfiguration    string
	EventSpecifics       string
}

// Event Requests
func (q *Queries) CreateEventRequest(ctx context.Context, arg CreateEventRequestParams) (EventRequest, error) {
	row := q.db.QueryRow(ctx, createEventRequest,
		arg.RequesterGuildID,
		arg.EventType,
		arg.Title,
		arg.Description,
		arg.ProposedStartDate,
		arg.ProposedEndDate,
		arg.Notes,
		arg.ParticipationDetails,
		arg.RoomConfiguration,
		arg.EventSpecifics,
	)
	var i EventRequest
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.RequesterGuildID,
		&i.ProcessedByAdminID,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.EventType,
		&i.Title,
		&i.Description,
		&i.ProposedStartDate,
		&i.ProposedEndDate,
		&i.Notes,
		&i.ParticipationDetails,
		&i.RoomConfiguration,
		&i.EventSpecifics,
		&i.RejectionReason,
		&i.ApprovedEventID,
	)
	return i, err
}

const createGuildLeaderboardEntry = `-- name: CreateGuildLeaderboardEntry :one
INSERT INTO guild_leaderboard_entries (guild_id, guild_name, event_id, rank, total_score)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, guild_id, guild_name, event_id, rank, total_score, snapshot_date
`

type CreateGuildLeaderboardEntryParams struct {
	GuildID    pgtype.UUID
	GuildName  string
	EventID    pgtype.UUID
	Rank       int32
	TotalScore int32
}

// Guild Leaderboard Entries
func (q *Queries) CreateGuildLeaderboardEntry(ctx context.Context, arg CreateGuildLeaderboardEntryParams) (GuildLeaderboardEntry, error) {
	row := q.db.QueryRow(ctx, createGuildLeaderboardEntry,
		arg.GuildID,
		arg.GuildName,
		arg.EventID,
		arg.Rank,
		arg.TotalScore,
	)
	var i GuildLeaderboardEntry
	err := row.Scan(
		&i.ID,
		&i.GuildID,
		&i.GuildName,
		&i.EventID,
		&i.Rank,
		&i.TotalScore,
		&i.SnapshotDate,
	)
	return i, err
}

const createLanguage = `-- name: CreateLanguage :one
INSERT INTO languages (name, compile_cmd, run_cmd, temp_file_dir, temp_file_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, compile_cmd, run_cmd, temp_file_dir, temp_file_name
`

type CreateLanguageParams struct {
	Name         string
	CompileCmd   string
	RunCmd       string
	TempFileDir  pgtype.Text
	TempFileName pgtype.Text
}

// Languages
func (q *Queries) CreateLanguage(ctx context.Context, arg CreateLanguageParams) (Language, error) {
	row := q.db.QueryRow(ctx, createLanguage,
		arg.Name,
		arg.CompileCmd,
		arg.RunCmd,
		arg.TempFileDir,
		arg.TempFileName,
	)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TempFileDir,
		&i.TempFileName,
	)
	return i, err
}

const createLeaderboardEntry = `-- name: CreateLeaderboardEntry :one
INSERT INTO leaderboard_entries (user_id, username, event_id, rank, score)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, username, event_id, rank, score, snapshot_date
`

type CreateLeaderboardEntryParams struct {
	UserID   pgtype.UUID
	Username string
	EventID  pgtype.UUID
	Rank     int32
	Score    int32
}

// Leaderboard Entries
func (q *Queries) CreateLeaderboardEntry(ctx context.Context, arg CreateLeaderboardEntryParams) (LeaderboardEntry, error) {
	row := q.db.QueryRow(ctx, createLeaderboardEntry,
		arg.UserID,
		arg.Username,
		arg.EventID,
		arg.Rank,
		arg.Score,
	)
	var i LeaderboardEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.EventID,
		&i.Rank,
		&i.Score,
		&i.SnapshotDate,
	)
	return i, err
}

const createRoom = `-- name: CreateRoom :one
INSERT INTO rooms (event_id, name, description)
VALUES ($1, $2, $3)
RETURNING id, event_id, name, description, created_date
`

type CreateRoomParams struct {
	EventID     pgtype.UUID
	Name        string
	Description string
}

// Rooms
func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, createRoom, arg.EventID, arg.Name, arg.Description)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.CreatedDate,
	)
	return i, err
}

const createRoomPlayer = `-- name: CreateRoomPlayer :one
INSERT INTO room_players (room_id, user_id, username, guild_id, score, place, state)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at
`

type CreateRoomPlayerParams struct {
	RoomID   pgtype.UUID
	UserID   pgtype.UUID
	Username string
	GuildID  pgtype.UUID
	Score    int32
	Place    pgtype.Int4
	State    RoomPlayerState
}

// Room Players
func (q *Queries) CreateRoomPlayer(ctx context.Context, arg CreateRoomPlayerParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, createRoomPlayer,
		arg.RoomID,
		arg.UserID,
		arg.Username,
		arg.GuildID,
		arg.Score,
		arg.Place,
		arg.State,
	)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.UserID,
		&i.GuildID,
		&i.Username,
		&i.Score,
		&i.Place,
		&i.State,
		&i.DisconnectedAt,
		&i.JoinedAt,
	)
	return i, err
}

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (user_id, code_problem_id, language_id, room_id, code_submitted, status, execution_time_ms)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, code_problem_id, language_id, room_id, code_submitted, status, execution_time_ms, submitted_at
`

type CreateSubmissionParams struct {
	UserID          pgtype.UUID
	CodeProblemID   pgtype.UUID
	LanguageID      pgtype.UUID
	RoomID          pgtype.UUID
	CodeSubmitted   string
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
}

// Submissions
func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, createSubmission,
		arg.UserID,
		arg.CodeProblemID,
		arg.LanguageID,
		arg.RoomID,
		arg.CodeSubmitted,
		arg.Status,
		arg.ExecutionTimeMs,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CodeProblemID,
		&i.LanguageID,
		&i.RoomID,
		&i.CodeSubmitted,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.SubmittedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name)
VALUES ($1)
RETURNING id, name, created_at
`

// Tags
func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (code_problem_id, input, expected_output, is_hidden)
VALUES ($1, $2, $3, $4)
RETURNING id, code_problem_id, input, expected_output, is_hidden
`

type CreateTestCaseParams struct {
	CodeProblemID  pgtype.UUID
	Input          string
	ExpectedOutput string
	IsHidden       bool
}

// Test Cases
func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, createTestCase,
		arg.CodeProblemID,
		arg.Input,
		arg.ExpectedOutput,
		arg.IsHidden,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.CodeProblemID,
		&i.Input,
		&i.ExpectedOutput,
		&i.IsHidden,
	)
	return i, err
}

const deleteCodeProblem = `-- name: DeleteCodeProblem :exec
DELETE FROM code_problems WHERE id = $1
`

func (q *Queries) DeleteCodeProblem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCodeProblem, id)
	return err
}

const deleteCodeProblemLanguageDetail = `-- name: DeleteCodeProblemLanguageDetail :exec
DELETE FROM code_problem_language_details
WHERE code_problem_id = $1 AND language_id = $2
`

type DeleteCodeProblemLanguageDetailParams struct {
	CodeProblemID pgtype.UUID
	LanguageID    pgtype.UUID
}

func (q *Queries) DeleteCodeProblemLanguageDetail(ctx context.Context, arg DeleteCodeProblemLanguageDetailParams) error {
	_, err := q.db.Exec(ctx, deleteCodeProblemLanguageDetail, arg.CodeProblemID, arg.LanguageID)
	return err
}

const deleteCodeProblemTag = `-- name: DeleteCodeProblemTag :exec
DELETE FROM code_problem_tags
WHERE code_problem_id = $1 AND tag_id = $2
`

type DeleteCodeProblemTagParams struct {
	CodeProblemID pgtype.UUID
	TagID         pgtype.UUID
}

func (q *Queries) DeleteCodeProblemTag(ctx context.Context, arg DeleteCodeProblemTagParams) error {
	_, err := q.db.Exec(ctx, deleteCodeProblemTag, arg.CodeProblemID, arg.TagID)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteEventCodeProblem = `-- name: DeleteEventCodeProblem :exec
DELETE FROM event_code_problems
WHERE event_id = $1 AND code_problem_id = $2
`

type DeleteEventCodeProblemParams struct {
	EventID       pgtype.UUID
	CodeProblemID pgtype.UUID
}

func (q *Queries) DeleteEventCodeProblem(ctx context.Context, arg DeleteEventCodeProblemParams) error {
	_, err := q.db.Exec(ctx, deleteEventCodeProblem, arg.EventID, arg.CodeProblemID)
	return err
}

const deleteEventGuildParticipant = `-- name: DeleteEventGuildParticipant :exec
DELETE FROM event_guild_participants
WHERE event_id = $1 AND guild_id = $2
`

type DeleteEventGuildParticipantParams struct {
	EventID pgtype.UUID
	GuildID pgtype.UUID
}

func (q *Queries) DeleteEventGuildParticipant(ctx context.Context, arg DeleteEventGuildParticipantParams) error {
	_, err := q.db.Exec(ctx, deleteEventGuildParticipant, arg.EventID, arg.GuildID)
	return err
}

const deleteGuildLeaderboardEntry = `-- name: DeleteGuildLeaderboardEntry :exec
DELETE FROM guild_leaderboard_entries
WHERE id = $1
`

func (q *Queries) DeleteGuildLeaderboardEntry(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteGuildLeaderboardEntry, id)
	return err
}

const deleteLanguage = `-- name: DeleteLanguage :exec
DELETE FROM languages WHERE id = $1
`

func (q *Queries) DeleteLanguage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLanguage, id)
	return err
}

const deleteLeaderboardEntry = `-- name: DeleteLeaderboardEntry :exec
DELETE FROM leaderboard_entries
WHERE id = $1
`

func (q *Queries) DeleteLeaderboardEntry(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLeaderboardEntry, id)
	return err
}

const deleteRoom = `-- name: DeleteRoom :exec
DELETE FROM rooms WHERE id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRoom, id)
	return err
}

const deleteRoomPlayer = `-- name: DeleteRoomPlayer :exec
DELETE FROM room_players
WHERE room_id = $1 AND user_id = $2
`

type DeleteRoomPlayerParams struct {
	RoomID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) DeleteRoomPlayer(ctx context.Context, arg DeleteRoomPlayerParams) error {
	_, err := q.db.Exec(ctx, deleteRoomPlayer, arg.RoomID, arg.UserID)
	return err
}

const deleteSubmission = `-- name: DeleteSubmission :exec
DELETE FROM submissions WHERE id = $1
`

func (q *Queries) DeleteSubmission(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubmission, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const deleteTestCase = `-- name: DeleteTestCase :exec
DELETE FROM test_cases WHERE id = $1
`

func (q *Queries) DeleteTestCase(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTestCase, id)
	return err
}

const disconnectRoomPlayer = `-- name: DisconnectRoomPlayer :one
UPDATE room_players
SET disconnected_at = NOW() AT TIME ZONE 'utc'
WHERE room_id = $1 AND user_id = $2
RETURNING room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at
`

type DisconnectRoomPlayerParams struct {
	RoomID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) DisconnectRoomPlayer(ctx context.Context, arg DisconnectRoomPlayerParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, disconnectRoomPlayer, arg.RoomID, arg.UserID)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.UserID,
		&i.GuildID,
		&i.Username,
		&i.Score,
		&i.Place,
		&i.State,
		&i.DisconnectedAt,
		&i.JoinedAt,
	)
	return i, err
}

const getActiveEvents = `-- name: GetActiveEvents :many
SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events
WHERE status = 'active'
ORDER BY started_date ASC
`

func (q *Queries) GetActiveEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getActiveEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeProblemByID = `-- name: GetCodeProblemByID :one
SELECT id, title, problem_statement, difficulty, created_at FROM code_problems WHERE id = $1
`

func (q *Queries) GetCodeProblemByID(ctx context.Context, id pgtype.UUID) (CodeProblem, error) {
	row := q.db.QueryRow(ctx, getCodeProblemByID, id)
	var i CodeProblem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ProblemStatement,
		&i.Difficulty,
		&i.CreatedAt,
	)
	return i, err
}

const getCodeProblemLanguage = `-- name: GetCodeProblemLanguage :one
SELECT code_problem_id, language_id, solution_stub, driver_code, time_constraint_ms, space_constraint_mb FROM code_problem_language_details
WHERE code_problem_id = $1 AND language_id = $2
`

type GetCodeProblemLanguageParams struct {
	CodeProblemID pgtype.UUID
	LanguageID    pgtype.UUID
}

func (q *Queries) GetCodeProblemLanguage(ctx context.Context, arg GetCodeProblemLanguageParams) (CodeProblemLanguageDetail, error) {
	row := q.db.QueryRow(ctx, getCodeProblemLanguage, arg.CodeProblemID, arg.LanguageID)
	var i CodeProblemLanguageDetail
	err := row.Scan(
		&i.CodeProblemID,
		&i.LanguageID,
		&i.SolutionStub,
		&i.DriverCode,
		&i.TimeConstraintMs,
		&i.SpaceConstraintMb,
	)
	return i, err
}

const getCodeProblemLanguageDetail = `-- name: GetCodeProblemLanguageDetail :one
SELECT code_problem_id, language_id, solution_stub, driver_code, time_constraint_ms, space_constraint_mb FROM code_problem_language_details
WHERE code_problem_id = $1 AND language_id = $2
`

type GetCodeProblemLanguageDetailParams struct {
	CodeProblemID pgtype.UUID
	LanguageID    pgtype.UUID
}

func (q *Queries) GetCodeProblemLanguageDetail(ctx context.Context, arg GetCodeProblemLanguageDetailParams) (CodeProblemLanguageDetail, error) {
	row := q.db.QueryRow(ctx, getCodeProblemLanguageDetail, arg.CodeProblemID, arg.LanguageID)
	var i CodeProblemLanguageDetail
	err := row.Scan(
		&i.CodeProblemID,
		&i.LanguageID,
		&i.SolutionStub,
		&i.DriverCode,
		&i.TimeConstraintMs,
		&i.SpaceConstraintMb,
	)
	return i, err
}

const getCodeProblemLanguageDetailByLanguageName = `-- name: GetCodeProblemLanguageDetailByLanguageName :one
SELECT cpld.code_problem_id, cpld.language_id, cpld.solution_stub, cpld.driver_code, cpld.time_constraint_ms, cpld.space_constraint_mb
FROM code_problem_language_details cpld
JOIN languages l ON cpld.language_id = l.id
WHERE cpld.code_problem_id = $1 AND l.name = $2
`

type GetCodeProblemLanguageDetailByLanguageNameParams struct {
	CodeProblemID pgtype.UUID
	Name          string
}

func (q *Queries) GetCodeProblemLanguageDetailByLanguageName(ctx context.Context, arg GetCodeProblemLanguageDetailByLanguageNameParams) (CodeProblemLanguageDetail, error) {
	row := q.db.QueryRow(ctx, getCodeProblemLanguageDetailByLanguageName, arg.CodeProblemID, arg.Name)
	var i CodeProblemLanguageDetail
	err := row.Scan(
		&i.CodeProblemID,
		&i.LanguageID,
		&i.SolutionStub,
		&i.DriverCode,
		&i.TimeConstraintMs,
		&i.SpaceConstraintMb,
	)
	return i, err
}

const getCodeProblemLanguageDetails = `-- name: GetCodeProblemLanguageDetails :many
SELECT code_problem_id, language_id, solution_stub, driver_code, time_constraint_ms, space_constraint_mb FROM code_problem_language_details
WHERE code_problem_id = $1
LIMIT $2
OFFSET $3
`

type GetCodeProblemLanguageDetailsParams struct {
	CodeProblemID pgtype.UUID
	Limit         int32
	Offset        int32
}

func (q *Queries) GetCodeProblemLanguageDetails(ctx context.Context, arg GetCodeProblemLanguageDetailsParams) ([]CodeProblemLanguageDetail, error) {
	rows, err := q.db.Query(ctx, getCodeProblemLanguageDetails, arg.CodeProblemID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CodeProblemLanguageDetail
	for rows.Next() {
		var i CodeProblemLanguageDetail
		if err := rows.Scan(
			&i.CodeProblemID,
			&i.LanguageID,
			&i.SolutionStub,
			&i.DriverCode,
			&i.TimeConstraintMs,
			&i.SpaceConstraintMb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeProblemTags = `-- name: GetCodeProblemTags :many
SELECT cpt.code_problem_id, cpt.tag_id, t.name as tag_name
FROM code_problem_tags cpt
JOIN tags t ON cpt.tag_id = t.id
WHERE cpt.code_problem_id = $1
`

type GetCodeProblemTagsRow struct {
	CodeProblemID pgtype.UUID
	TagID         pgtype.UUID
	TagName       string
}

func (q *Queries) GetCodeProblemTags(ctx context.Context, codeProblemID pgtype.UUID) ([]GetCodeProblemTagsRow, error) {
	rows, err := q.db.Query(ctx, getCodeProblemTags, codeProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCodeProblemTagsRow
	for rows.Next() {
		var i GetCodeProblemTagsRow
		if err := rows.Scan(&i.CodeProblemID, &i.TagID, &i.TagName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeProblems = `-- name: GetCodeProblems :many
SELECT id, title, problem_statement, difficulty, created_at FROM code_problems
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type GetCodeProblemsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCodeProblems(ctx context.Context, arg GetCodeProblemsParams) ([]CodeProblem, error) {
	rows, err := q.db.Query(ctx, getCodeProblems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CodeProblem
	for rows.Next() {
		var i CodeProblem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ProblemStatement,
			&i.Difficulty,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeProblemsByCriteria = `-- name: GetCodeProblemsByCriteria :many
SELECT DISTINCT cp.id, cp.title, cp.problem_statement, cp.difficulty, cp.created_at
FROM code_problems cp
LEFT JOIN code_problem_tags cpt ON cp.id = cpt.code_problem_id
LEFT JOIN tags t ON cpt.tag_id = t.id
WHERE
  ($1::int IS NULL OR cp.difficulty = $1::int)
  AND ($2::text[] IS NULL OR t.name = ANY($2::text[]))
ORDER BY cp.created_at DESC
LIMIT $4
OFFSET $3
`

type GetCodeProblemsByCriteriaParams struct {
	Difficulty  pgtype.Int4
	TagNames    []string
	OffsetCount int32
	LimitCount  int32
}

func (q *Queries) GetCodeProblemsByCriteria(ctx context.Context, arg GetCodeProblemsByCriteriaParams) ([]CodeProblem, error) {
	rows, err := q.db.Query(ctx, getCodeProblemsByCriteria,
		arg.Difficulty,
		arg.TagNames,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CodeProblem
	for rows.Next() {
		var i CodeProblem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ProblemStatement,
			&i.Difficulty,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeProblemsByDifficulty = `-- name: GetCodeProblemsByDifficulty :many
SELECT id, title, problem_statement, difficulty, created_at FROM code_problems
WHERE difficulty = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetCodeProblemsByDifficultyParams struct {
	Difficulty int32
	Limit      int32
	Offset     int32
}

func (q *Queries) GetCodeProblemsByDifficulty(ctx context.Context, arg GetCodeProblemsByDifficultyParams) ([]CodeProblem, error) {
	rows, err := q.db.Query(ctx, getCodeProblemsByDifficulty, arg.Difficulty, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CodeProblem
	for rows.Next() {
		var i CodeProblem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ProblemStatement,
			&i.Difficulty,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeProblemsByTag = `-- name: GetCodeProblemsByTag :many
SELECT cp.id, cp.title, cp.problem_statement, cp.difficulty, cp.created_at, t.name as tag_name
FROM code_problems cp
JOIN code_problem_tags cpt ON cp.id = cpt.code_problem_id
JOIN tags t ON cpt.tag_id = t.id
WHERE t.id = $1
ORDER BY cp.created_at DESC
`

type GetCodeProblemsByTagRow struct {
	ID               pgtype.UUID
	Title            string
	ProblemStatement string
	Difficulty       int32
	CreatedAt        pgtype.Timestamptz
	TagName          string
}

func (q *Queries) GetCodeProblemsByTag(ctx context.Context, id pgtype.UUID) ([]GetCodeProblemsByTagRow, error) {
	rows, err := q.db.Query(ctx, getCodeProblemsByTag, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCodeProblemsByTagRow
	for rows.Next() {
		var i GetCodeProblemsByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ProblemStatement,
			&i.Difficulty,
			&i.CreatedAt,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events WHERE id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartedDate,
		&i.EndDate,
		&i.MaxGuilds,
		&i.MaxPlayersPerGuild,
		&i.NumberOfRooms,
		&i.GuildsPerRoom,
		&i.RoomNamingPrefix,
		&i.OriginalRequestID,
		&i.Status,
		&i.AssignmentDate,
	)
	return i, err
}

const getEventCodeProblem = `-- name: GetEventCodeProblem :one
SELECT ecp.event_id, ecp.code_problem_id, ecp.score, cp.title, cp.difficulty
FROM event_code_problems ecp
JOIN code_problems cp ON ecp.code_problem_id = cp.id
WHERE ecp.event_id = $1 AND ecp.code_problem_id = $2
`

type GetEventCodeProblemParams struct {
	EventID       pgtype.UUID
	CodeProblemID pgtype.UUID
}

type GetEventCodeProblemRow struct {
	EventID       pgtype.UUID
	CodeProblemID pgtype.UUID
	Score         int32
	Title         string
	Difficulty    int32
}

func (q *Queries) GetEventCodeProblem(ctx context.Context, arg GetEventCodeProblemParams) (GetEventCodeProblemRow, error) {
	row := q.db.QueryRow(ctx, getEventCodeProblem, arg.EventID, arg.CodeProblemID)
	var i GetEventCodeProblemRow
	err := row.Scan(
		&i.EventID,
		&i.CodeProblemID,
		&i.Score,
		&i.Title,
		&i.Difficulty,
	)
	return i, err
}

const getEventCodeProblems = `-- name: GetEventCodeProblems :many
SELECT ecp.event_id, ecp.code_problem_id, ecp.score, cp.title, cp.difficulty, cp.problem_statement
FROM event_code_problems ecp
JOIN code_problems cp ON ecp.code_problem_id = cp.id
WHERE ecp.event_id = $1
ORDER BY ecp.score DESC
`

type GetEventCodeProblemsRow struct {
	EventID          pgtype.UUID
	CodeProblemID    pgtype.UUID
	Score            int32
	Title            string
	Difficulty       int32
	ProblemStatement string
}

func (q *Queries) GetEventCodeProblems(ctx context.Context, eventID pgtype.UUID) ([]GetEventCodeProblemsRow, error) {
	rows, err := q.db.Query(ctx, getEventCodeProblems, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventCodeProblemsRow
	for rows.Next() {
		var i GetEventCodeProblemsRow
		if err := rows.Scan(
			&i.EventID,
			&i.CodeProblemID,
			&i.Score,
			&i.Title,
			&i.Difficulty,
			&i.ProblemStatement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventGuildParticipant = `-- name: GetEventGuildParticipant :one
SELECT event_id, guild_id, joined_at, room_id FROM event_guild_participants
WHERE event_id = $1 AND guild_id = $2
`

type GetEventGuildParticipantParams struct {
	EventID pgtype.UUID
	GuildID pgtype.UUID
}

func (q *Queries) GetEventGuildParticipant(ctx context.Context, arg GetEventGuildParticipantParams) (EventGuildParticipant, error) {
	row := q.db.QueryRow(ctx, getEventGuildParticipant, arg.EventID, arg.GuildID)
	var i EventGuildParticipant
	err := row.Scan(
		&i.EventID,
		&i.GuildID,
		&i.JoinedAt,
		&i.RoomID,
	)
	return i, err
}

const getEventGuildParticipants = `-- name: GetEventGuildParticipants :many
SELECT event_id, guild_id, joined_at, room_id FROM event_guild_participants
WHERE event_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) GetEventGuildParticipants(ctx context.Context, eventID pgtype.UUID) ([]EventGuildParticipant, error) {
	rows, err := q.db.Query(ctx, getEventGuildParticipants, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventGuildParticipant
	for rows.Next() {
		var i EventGuildParticipant
		if err := rows.Scan(
			&i.EventID,
			&i.GuildID,
			&i.JoinedAt,
			&i.RoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventParticipants = `-- name: GetEventParticipants :many
SELECT event_id, guild_id, joined_at, room_id FROM event_guild_participants
WHERE event_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) GetEventParticipants(ctx context.Context, eventID pgtype.UUID) ([]EventGuildParticipant, error) {
	rows, err := q.db.Query(ctx, getEventParticipants, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventGuildParticipant
	for rows.Next() {
		var i EventGuildParticipant
		if err := rows.Scan(
			&i.EventID,
			&i.GuildID,
			&i.JoinedAt,
			&i.RoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventRequestByID = `-- name: GetEventRequestByID :one
SELECT id, status, requester_guild_id, processed_by_admin_id, created_at, processed_at, event_type, title, description, proposed_start_date, proposed_end_date, notes, participation_details, room_configuration, event_specifics, rejection_reason, approved_event_id FROM event_requests WHERE id = $1
`

func (q *Queries) GetEventRequestByID(ctx context.Context, id pgtype.UUID) (EventRequest, error) {
	row := q.db.QueryRow(ctx, getEventRequestByID, id)
	var i EventRequest
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.RequesterGuildID,
		&i.ProcessedByAdminID,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.EventType,
		&i.Title,
		&i.Description,
		&i.ProposedStartDate,
		&i.ProposedEndDate,
		&i.Notes,
		&i.ParticipationDetails,
		&i.RoomConfiguration,
		&i.EventSpecifics,
		&i.RejectionReason,
		&i.ApprovedEventID,
	)
	return i, err
}

const getEventStatistics = `-- name: GetEventStatistics :one
WITH event_rooms AS (
  SELECT id FROM rooms WHERE event_id = $1
),
player_stats AS (
  SELECT
    COUNT(DISTINCT rp.user_id) as total_participants,
    COALESCE(AVG(rp.score), 0) as average_score,
    COALESCE(MAX(rp.score), 0) as highest_score
  FROM room_players rp
  WHERE rp.room_id IN (SELECT id FROM event_rooms)
    AND rp.state IN ('completed'::room_player_state, 'present'::room_player_state)
),
submission_stats AS (
  SELECT
    COUNT(*) as total_submissions,
    COUNT(CASE WHEN s.status = 'accepted' THEN 1 END) as accepted_submissions
  FROM submissions s
  WHERE s.room_id IN (SELECT id FROM event_rooms)
)
SELECT
  ps.total_participants::integer,
  ss.total_submissions::integer,
  ss.accepted_submissions::integer,
  CASE
    WHEN ss.total_submissions > 0 THEN
      ROUND((ss.accepted_submissions::numeric / ss.total_submissions::numeric) * 100, 2)
    ELSE 0
  END as acceptance_rate,
  ROUND(ps.average_score::numeric, 2) as average_score,
  ps.highest_score::integer,
  (SELECT COUNT(*) FROM event_rooms)::integer as total_rooms
FROM player_stats ps, submission_stats ss
`

type GetEventStatisticsRow struct {
	PsTotalParticipants   int32
	SsTotalSubmissions    int32
	SsAcceptedSubmissions int32
	AcceptanceRate        int32
	AverageScore          pgtype.Numeric
	PsHighestScore        int32
	TotalRooms            int32
}

// Get aggregate statistics for an event
// P2-1: Used to populate EventExpired message with event stats
func (q *Queries) GetEventStatistics(ctx context.Context, eventID pgtype.UUID) (GetEventStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getEventStatistics, eventID)
	var i GetEventStatisticsRow
	err := row.Scan(
		&i.PsTotalParticipants,
		&i.SsTotalSubmissions,
		&i.SsAcceptedSubmissions,
		&i.AcceptanceRate,
		&i.AverageScore,
		&i.PsHighestScore,
		&i.TotalRooms,
	)
	return i, err
}

const getEventWithProblemsAndLanguages = `-- name: GetEventWithProblemsAndLanguages :many
SELECT
    e.id, e.title, e.description, e.type, e.started_date, e.end_date, e.max_guilds, e.max_players_per_guild, e.number_of_rooms, e.guilds_per_room, e.room_naming_prefix, e.original_request_id, e.status, e.assignment_date,
    cp.id as problem_id,
    cp.title as problem_title,
    cp.difficulty as problem_difficulty,
    ecp.score as problem_score
FROM events e
LEFT JOIN event_code_problems ecp ON e.id = ecp.event_id
LEFT JOIN code_problems cp ON ecp.code_problem_id = cp.id
WHERE e.id = $1
ORDER BY ecp.score DESC
`

type GetEventWithProblemsAndLanguagesRow struct {
	ID                 pgtype.UUID
	Title              string
	Description        string
	Type               EventType
	StartedDate        pgtype.Timestamptz
	EndDate            pgtype.Timestamptz
	MaxGuilds          pgtype.Int4
	MaxPlayersPerGuild pgtype.Int4
	NumberOfRooms      pgtype.Int4
	GuildsPerRoom      pgtype.Int4
	RoomNamingPrefix   pgtype.Text
	OriginalRequestID  pgtype.UUID
	Status             EventStatus
	AssignmentDate     pgtype.Timestamptz
	ProblemID          pgtype.UUID
	ProblemTitle       pgtype.Text
	ProblemDifficulty  pgtype.Int4
	ProblemScore       pgtype.Int4
}

// Complex Queries
func (q *Queries) GetEventWithProblemsAndLanguages(ctx context.Context, id pgtype.UUID) ([]GetEventWithProblemsAndLanguagesRow, error) {
	rows, err := q.db.Query(ctx, getEventWithProblemsAndLanguages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventWithProblemsAndLanguagesRow
	for rows.Next() {
		var i GetEventWithProblemsAndLanguagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
			&i.ProblemID,
			&i.ProblemTitle,
			&i.ProblemDifficulty,
			&i.ProblemScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvents = `-- name: GetEvents :many
SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events
ORDER BY started_date ASC
LIMIT $1
OFFSET $2
`

type GetEventsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByStatus = `-- name: GetEventsByStatus :many
SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events
WHERE status = $1
ORDER BY started_date ASC
LIMIT $2
OFFSET $3
`

type GetEventsByStatusParams struct {
	Status EventStatus
	Limit  int32
	Offset int32
}

// Filter events by status with pagination
func (q *Queries) GetEventsByStatus(ctx context.Context, arg GetEventsByStatusParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByType = `-- name: GetEventsByType :many
SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events
WHERE type = $1
ORDER BY started_date ASC
`

func (q *Queries) GetEventsByType(ctx context.Context, type_ EventType) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredActiveEvents = `-- name: GetExpiredActiveEvents :many
SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events
WHERE status = 'active'
  AND end_date < NOW() AT TIME ZONE 'utc'
ORDER BY end_date ASC
`

// Find events that are stuck in 'active' status but have already expired
// This is used by the background job to detect and complete orphaned events
// whose expiry timers were lost due to crashes or failures
func (q *Queries) GetExpiredActiveEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getExpiredActiveEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuildLeaderboardByEvent = `-- name: GetGuildLeaderboardByEvent :many
SELECT id, guild_id, guild_name, event_id, rank, total_score, snapshot_date FROM guild_leaderboard_entries
WHERE event_id = $1
ORDER BY rank ASC
`

func (q *Queries) GetGuildLeaderboardByEvent(ctx context.Context, eventID pgtype.UUID) ([]GuildLeaderboardEntry, error) {
	rows, err := q.db.Query(ctx, getGuildLeaderboardByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GuildLeaderboardEntry
	for rows.Next() {
		var i GuildLeaderboardEntry
		if err := rows.Scan(
			&i.ID,
			&i.GuildID,
			&i.GuildName,
			&i.EventID,
			&i.Rank,
			&i.TotalScore,
			&i.SnapshotDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuildLeaderboardByGuild = `-- name: GetGuildLeaderboardByGuild :many
SELECT gle.id, gle.guild_id, gle.guild_name, gle.event_id, gle.rank, gle.total_score, gle.snapshot_date, e.title as event_title
FROM guild_leaderboard_entries gle
JOIN events e ON gle.event_id = e.id
WHERE gle.guild_id = $1
ORDER BY gle.snapshot_date DESC
`

type GetGuildLeaderboardByGuildRow struct {
	ID           pgtype.UUID
	GuildID      pgtype.UUID
	GuildName    string
	EventID      pgtype.UUID
	Rank         int32
	TotalScore   int32
	SnapshotDate pgtype.Timestamptz
	EventTitle   string
}

func (q *Queries) GetGuildLeaderboardByGuild(ctx context.Context, guildID pgtype.UUID) ([]GetGuildLeaderboardByGuildRow, error) {
	rows, err := q.db.Query(ctx, getGuildLeaderboardByGuild, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGuildLeaderboardByGuildRow
	for rows.Next() {
		var i GetGuildLeaderboardByGuildRow
		if err := rows.Scan(
			&i.ID,
			&i.GuildID,
			&i.GuildName,
			&i.EventID,
			&i.Rank,
			&i.TotalScore,
			&i.SnapshotDate,
			&i.EventTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuildParticipantsByGuild = `-- name: GetGuildParticipantsByGuild :many
SELECT event_id, guild_id, joined_at, room_id FROM event_guild_participants
WHERE guild_id = $1
ORDER BY joined_at DESC
`

func (q *Queries) GetGuildParticipantsByGuild(ctx context.Context, guildID pgtype.UUID) ([]EventGuildParticipant, error) {
	rows, err := q.db.Query(ctx, getGuildParticipantsByGuild, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventGuildParticipant
	for rows.Next() {
		var i EventGuildParticipant
		if err := rows.Scan(
			&i.EventID,
			&i.GuildID,
			&i.JoinedAt,
			&i.RoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLanguageByID = `-- name: GetLanguageByID :one
SELECT id, name, compile_cmd, run_cmd, temp_file_dir, temp_file_name FROM languages WHERE id = $1
`

func (q *Queries) GetLanguageByID(ctx context.Context, id pgtype.UUID) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguageByID, id)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TempFileDir,
		&i.TempFileName,
	)
	return i, err
}

const getLanguageByName = `-- name: GetLanguageByName :one
SELECT id, name, compile_cmd, run_cmd, temp_file_dir, temp_file_name FROM languages WHERE name = $1
`

func (q *Queries) GetLanguageByName(ctx context.Context, name string) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguageByName, name)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TempFileDir,
		&i.TempFileName,
	)
	return i, err
}

const getLanguageDetailsForProblem = `-- name: GetLanguageDetailsForProblem :many
SELECT cpld.code_problem_id, cpld.language_id, cpld.solution_stub, cpld.driver_code, cpld.time_constraint_ms, cpld.space_constraint_mb, l.name as language_name
FROM code_problem_language_details cpld
JOIN languages l ON cpld.language_id = l.id
WHERE cpld.code_problem_id = $1
`

type GetLanguageDetailsForProblemRow struct {
	CodeProblemID     pgtype.UUID
	LanguageID        pgtype.UUID
	SolutionStub      string
	DriverCode        string
	TimeConstraintMs  int32
	SpaceConstraintMb int32
	LanguageName      string
}

func (q *Queries) GetLanguageDetailsForProblem(ctx context.Context, codeProblemID pgtype.UUID) ([]GetLanguageDetailsForProblemRow, error) {
	rows, err := q.db.Query(ctx, getLanguageDetailsForProblem, codeProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLanguageDetailsForProblemRow
	for rows.Next() {
		var i GetLanguageDetailsForProblemRow
		if err := rows.Scan(
			&i.CodeProblemID,
			&i.LanguageID,
			&i.SolutionStub,
			&i.DriverCode,
			&i.TimeConstraintMs,
			&i.SpaceConstraintMb,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLanguages = `-- name: GetLanguages :many
SELECT id, name, compile_cmd, run_cmd, temp_file_dir, temp_file_name
FROM languages
ORDER BY name
LIMIT $1
OFFSET $2
`

type GetLanguagesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetLanguages(ctx context.Context, arg GetLanguagesParams) ([]Language, error) {
	rows, err := q.db.Query(ctx, getLanguages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CompileCmd,
			&i.RunCmd,
			&i.TempFileDir,
			&i.TempFileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGuildLeaderboardByEvent = `-- name: GetLatestGuildLeaderboardByEvent :many
SELECT id, guild_id, guild_name, event_id, rank, total_score, snapshot_date FROM guild_leaderboard_entries gle1
WHERE gle1.event_id = $1
AND gle1.snapshot_date = (
    SELECT MAX(gle2.snapshot_date)
    FROM guild_leaderboard_entries gle2
    WHERE gle2.event_id = $1
)
ORDER BY gle1.rank ASC
`

func (q *Queries) GetLatestGuildLeaderboardByEvent(ctx context.Context, eventID pgtype.UUID) ([]GuildLeaderboardEntry, error) {
	rows, err := q.db.Query(ctx, getLatestGuildLeaderboardByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GuildLeaderboardEntry
	for rows.Next() {
		var i GuildLeaderboardEntry
		if err := rows.Scan(
			&i.ID,
			&i.GuildID,
			&i.GuildName,
			&i.EventID,
			&i.Rank,
			&i.TotalScore,
			&i.SnapshotDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestLeaderboardByEvent = `-- name: GetLatestLeaderboardByEvent :many
SELECT id, user_id, username, event_id, rank, score, snapshot_date FROM leaderboard_entries le1
WHERE le1.event_id = $1
AND le1.snapshot_date = (
    SELECT MAX(le2.snapshot_date)
    FROM leaderboard_entries le2
    WHERE le2.event_id = $1
)
ORDER BY le1.rank ASC
`

func (q *Queries) GetLatestLeaderboardByEvent(ctx context.Context, eventID pgtype.UUID) ([]LeaderboardEntry, error) {
	rows, err := q.db.Query(ctx, getLatestLeaderboardByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeaderboardEntry
	for rows.Next() {
		var i LeaderboardEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.EventID,
			&i.Rank,
			&i.Score,
			&i.SnapshotDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboardByEvent = `-- name: GetLeaderboardByEvent :many
SELECT id, user_id, username, event_id, rank, score, snapshot_date FROM leaderboard_entries
WHERE event_id = $1
ORDER BY rank ASC
`

func (q *Queries) GetLeaderboardByEvent(ctx context.Context, eventID pgtype.UUID) ([]LeaderboardEntry, error) {
	rows, err := q.db.Query(ctx, getLeaderboardByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeaderboardEntry
	for rows.Next() {
		var i LeaderboardEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.EventID,
			&i.Rank,
			&i.Score,
			&i.SnapshotDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboardByUser = `-- name: GetLeaderboardByUser :many
SELECT le.id, le.user_id, le.username, le.event_id, le.rank, le.score, le.snapshot_date, e.title as event_title
FROM leaderboard_entries le
JOIN events e ON le.event_id = e.id
WHERE le.user_id = $1
ORDER BY le.snapshot_date DESC
`

type GetLeaderboardByUserRow struct {
	ID           pgtype.UUID
	UserID       pgtype.UUID
	Username     string
	EventID      pgtype.UUID
	Rank         int32
	Score        int32
	SnapshotDate pgtype.Timestamptz
	EventTitle   string
}

func (q *Queries) GetLeaderboardByUser(ctx context.Context, userID pgtype.UUID) ([]GetLeaderboardByUserRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboardByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardByUserRow
	for rows.Next() {
		var i GetLeaderboardByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.EventID,
			&i.Rank,
			&i.Score,
			&i.SnapshotDate,
			&i.EventTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEventsForAssignment = `-- name: GetPendingEventsForAssignment :many

SELECT id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date FROM events
WHERE status = 'pending'
  AND assignment_date <= NOW() AT TIME ZONE 'utc'
ORDER BY assignment_date ASC
`

// ========================================
// Event Assignment Queries (for scheduled guild-to-room assignment)
// ========================================
// Get all events that are ready for guild-to-room assignment
// (assignment_date has passed and status is still 'pending')
func (q *Queries) GetPendingEventsForAssignment(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getPendingEventsForAssignment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartedDate,
			&i.EndDate,
			&i.MaxGuilds,
			&i.MaxPlayersPerGuild,
			&i.NumberOfRooms,
			&i.GuildsPerRoom,
			&i.RoomNamingPrefix,
			&i.OriginalRequestID,
			&i.Status,
			&i.AssignmentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersByUserID = `-- name: GetPlayersByUserID :many
SELECT room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at FROM room_players
WHERE user_id = $1
ORDER BY score DESC
`

func (q *Queries) GetPlayersByUserID(ctx context.Context, userID pgtype.UUID) ([]RoomPlayer, error) {
	rows, err := q.db.Query(ctx, getPlayersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoomPlayer
	for rows.Next() {
		var i RoomPlayer
		if err := rows.Scan(
			&i.RoomID,
			&i.UserID,
			&i.GuildID,
			&i.Username,
			&i.Score,
			&i.Place,
			&i.State,
			&i.DisconnectedAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemSubmissionStats = `-- name: GetProblemSubmissionStats :one
SELECT
    COUNT(*) as total_submissions,
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(CASE WHEN status = 'accepted' THEN 1 END) as accepted_count,
    ROUND(COUNT(CASE WHEN status = 'accepted' THEN 1 END) * 100.0 / COUNT(*), 2) as acceptance_rate
FROM submissions
WHERE code_problem_id = $1
`

type GetProblemSubmissionStatsRow struct {
	TotalSubmissions int64
	UniqueUsers      int64
	AcceptedCount    int64
	AcceptanceRate   pgtype.Numeric
}

func (q *Queries) GetProblemSubmissionStats(ctx context.Context, codeProblemID pgtype.UUID) (GetProblemSubmissionStatsRow, error) {
	row := q.db.QueryRow(ctx, getProblemSubmissionStats, codeProblemID)
	var i GetProblemSubmissionStatsRow
	err := row.Scan(
		&i.TotalSubmissions,
		&i.UniqueUsers,
		&i.AcceptedCount,
		&i.AcceptanceRate,
	)
	return i, err
}

const getPublicTestCasesByProblem = `-- name: GetPublicTestCasesByProblem :many
SELECT id, code_problem_id, input, expected_output, is_hidden FROM test_cases
WHERE code_problem_id = $1 AND is_hidden = false
ORDER BY id
`

func (q *Queries) GetPublicTestCasesByProblem(ctx context.Context, codeProblemID pgtype.UUID) ([]TestCase, error) {
	rows, err := q.db.Query(ctx, getPublicTestCasesByProblem, codeProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.CodeProblemID,
			&i.Input,
			&i.ExpectedOutput,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomCodeProblemsByDifficultyAndTags = `-- name: GetRandomCodeProblemsByDifficultyAndTags :many
SELECT cp.id, cp.title, cp.problem_statement, cp.difficulty, cp.created_at
FROM code_problems cp
WHERE cp.id IN (
  SELECT DISTINCT cp2.id
  FROM code_problems cp2
  INNER JOIN code_problem_tags cpt ON cp2.id = cpt.code_problem_id
  WHERE
    cp2.difficulty = $1::int
    AND (
      $2::uuid[] IS NULL
      OR $2::uuid[] = '{}'
      OR cpt.tag_id = ANY($2::uuid[])
    )
    AND NOT (cp2.id = ANY($3::uuid[]))
)
ORDER BY RANDOM()
LIMIT $4
`

type GetRandomCodeProblemsByDifficultyAndTagsParams struct {
	Difficulty         int32
	TagIds             []pgtype.UUID
	ExcludedProblemIds []pgtype.UUID
	LimitCount         int32
}

// Randomly select code problems based on difficulty and tag IDs
// This is optimized for event problem assignment
func (q *Queries) GetRandomCodeProblemsByDifficultyAndTags(ctx context.Context, arg GetRandomCodeProblemsByDifficultyAndTagsParams) ([]CodeProblem, error) {
	rows, err := q.db.Query(ctx, getRandomCodeProblemsByDifficultyAndTags,
		arg.Difficulty,
		arg.TagIds,
		arg.ExcludedProblemIds,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CodeProblem
	for rows.Next() {
		var i CodeProblem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ProblemStatement,
			&i.Difficulty,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomByID = `-- name: GetRoomByID :one
SELECT id, event_id, name, description, created_date FROM rooms WHERE id = $1
`

func (q *Queries) GetRoomByID(ctx context.Context, id pgtype.UUID) (Room, error) {
	row := q.db.QueryRow(ctx, getRoomByID, id)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.CreatedDate,
	)
	return i, err
}

const getRoomLeaderboard = `-- name: GetRoomLeaderboard :many
SELECT
    rp.room_id, rp.user_id, rp.guild_id, rp.username, rp.score, rp.place, rp.state, rp.disconnected_at, rp.joined_at,
    COUNT(s.id) as submission_count,
    MAX(s.submitted_at) as last_submission
FROM room_players rp
LEFT JOIN submissions s ON rp.user_id = s.user_id AND s.room_id = rp.room_id
WHERE rp.room_id = $1
GROUP BY rp.room_id, rp.user_id
ORDER BY rp.score DESC, rp.place ASC
`

type GetRoomLeaderboardRow struct {
	RoomID          pgtype.UUID
	UserID          pgtype.UUID
	GuildID         pgtype.UUID
	Username        string
	Score           int32
	Place           pgtype.Int4
	State           RoomPlayerState
	DisconnectedAt  pgtype.Timestamptz
	JoinedAt        pgtype.Timestamptz
	SubmissionCount int64
	LastSubmission  interface{}
}

func (q *Queries) GetRoomLeaderboard(ctx context.Context, roomID pgtype.UUID) ([]GetRoomLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getRoomLeaderboard, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomLeaderboardRow
	for rows.Next() {
		var i GetRoomLeaderboardRow
		if err := rows.Scan(
			&i.RoomID,
			&i.UserID,
			&i.GuildID,
			&i.Username,
			&i.Score,
			&i.Place,
			&i.State,
			&i.DisconnectedAt,
			&i.JoinedAt,
			&i.SubmissionCount,
			&i.LastSubmission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomPlayer = `-- name: GetRoomPlayer :one
SELECT room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at FROM room_players
WHERE room_id = $1 AND user_id = $2
`

type GetRoomPlayerParams struct {
	RoomID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) GetRoomPlayer(ctx context.Context, arg GetRoomPlayerParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, getRoomPlayer, arg.RoomID, arg.UserID)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.UserID,
		&i.GuildID,
		&i.Username,
		&i.Score,
		&i.Place,
		&i.State,
		&i.DisconnectedAt,
		&i.JoinedAt,
	)
	return i, err
}

const getRoomPlayers = `-- name: GetRoomPlayers :many
SELECT room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at FROM room_players
WHERE room_id = $1
ORDER BY score DESC, place ASC
`

func (q *Queries) GetRoomPlayers(ctx context.Context, roomID pgtype.UUID) ([]RoomPlayer, error) {
	rows, err := q.db.Query(ctx, getRoomPlayers, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoomPlayer
	for rows.Next() {
		var i RoomPlayer
		if err := rows.Scan(
			&i.RoomID,
			&i.UserID,
			&i.GuildID,
			&i.Username,
			&i.Score,
			&i.Place,
			&i.State,
			&i.DisconnectedAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsByEvent = `-- name: GetRoomsByEvent :many
SELECT id, event_id, name, description, created_date FROM rooms
WHERE event_id = $1
ORDER BY created_date ASC
`

func (q *Queries) GetRoomsByEvent(ctx context.Context, eventID pgtype.UUID) ([]Room, error) {
	rows, err := q.db.Query(ctx, getRoomsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Room
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Description,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsWithEventDetails = `-- name: GetRoomsWithEventDetails :many
SELECT r.id, r.event_id, r.name, r.description, r.created_date, e.title as event_title, e.type as event_type
FROM rooms r
JOIN events e ON r.event_id = e.id
WHERE r.event_id = $1
ORDER BY r.created_date ASC
`

type GetRoomsWithEventDetailsRow struct {
	ID          pgtype.UUID
	EventID     pgtype.UUID
	Name        string
	Description string
	CreatedDate pgtype.Timestamptz
	EventTitle  string
	EventType   EventType
}

func (q *Queries) GetRoomsWithEventDetails(ctx context.Context, eventID pgtype.UUID) ([]GetRoomsWithEventDetailsRow, error) {
	rows, err := q.db.Query(ctx, getRoomsWithEventDetails, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsWithEventDetailsRow
	for rows.Next() {
		var i GetRoomsWithEventDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Description,
			&i.CreatedDate,
			&i.EventTitle,
			&i.EventType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionByID = `-- name: GetSubmissionByID :one
SELECT id, user_id, code_problem_id, language_id, room_id, code_submitted, status, execution_time_ms, submitted_at FROM submissions WHERE id = $1
`

func (q *Queries) GetSubmissionByID(ctx context.Context, id pgtype.UUID) (Submission, error) {
	row := q.db.QueryRow(ctx, getSubmissionByID, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CodeProblemID,
		&i.LanguageID,
		&i.RoomID,
		&i.CodeSubmitted,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.SubmittedAt,
	)
	return i, err
}

const getSubmissionsByGuild = `-- name: GetSubmissionsByGuild :many
SELECT s.id, s.user_id, s.code_problem_id, s.language_id, s.room_id, s.code_submitted, s.status, s.execution_time_ms, s.submitted_at, cp.title as problem_title, l.name as language_name
FROM submissions s
JOIN code_problems cp ON s.code_problem_id = cp.id
JOIN languages l ON s.language_id = l.id
JOIN room_players rp ON s.user_id = rp.user_id AND s.room_id = rp.room_id
WHERE rp.guild_id = $1
ORDER BY s.submitted_at DESC
`

type GetSubmissionsByGuildRow struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	CodeProblemID   pgtype.UUID
	LanguageID      pgtype.UUID
	RoomID          pgtype.UUID
	CodeSubmitted   string
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
	SubmittedAt     pgtype.Timestamptz
	ProblemTitle    string
	LanguageName    string
}

func (q *Queries) GetSubmissionsByGuild(ctx context.Context, guildID pgtype.UUID) ([]GetSubmissionsByGuildRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByGuild, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByGuildRow
	for rows.Next() {
		var i GetSubmissionsByGuildRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeProblemID,
			&i.LanguageID,
			&i.RoomID,
			&i.CodeSubmitted,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.SubmittedAt,
			&i.ProblemTitle,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByProblem = `-- name: GetSubmissionsByProblem :many
SELECT s.id, s.user_id, s.code_problem_id, s.language_id, s.room_id, s.code_submitted, s.status, s.execution_time_ms, s.submitted_at, l.name as language_name
FROM submissions s
JOIN languages l ON s.language_id = l.id
WHERE s.code_problem_id = $1
ORDER BY s.submitted_at DESC
`

type GetSubmissionsByProblemRow struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	CodeProblemID   pgtype.UUID
	LanguageID      pgtype.UUID
	RoomID          pgtype.UUID
	CodeSubmitted   string
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
	SubmittedAt     pgtype.Timestamptz
	LanguageName    string
}

func (q *Queries) GetSubmissionsByProblem(ctx context.Context, codeProblemID pgtype.UUID) ([]GetSubmissionsByProblemRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByProblem, codeProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByProblemRow
	for rows.Next() {
		var i GetSubmissionsByProblemRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeProblemID,
			&i.LanguageID,
			&i.RoomID,
			&i.CodeSubmitted,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.SubmittedAt,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByRoom = `-- name: GetSubmissionsByRoom :many
SELECT s.id, s.user_id, s.code_problem_id, s.language_id, s.room_id, s.code_submitted, s.status, s.execution_time_ms, s.submitted_at, cp.title as problem_title, l.name as language_name
FROM submissions s
JOIN code_problems cp ON s.code_problem_id = cp.id
JOIN languages l ON s.language_id = l.id
WHERE s.room_id = $1
ORDER BY s.submitted_at DESC
`

type GetSubmissionsByRoomRow struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	CodeProblemID   pgtype.UUID
	LanguageID      pgtype.UUID
	RoomID          pgtype.UUID
	CodeSubmitted   string
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
	SubmittedAt     pgtype.Timestamptz
	ProblemTitle    string
	LanguageName    string
}

func (q *Queries) GetSubmissionsByRoom(ctx context.Context, roomID pgtype.UUID) ([]GetSubmissionsByRoomRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByRoom, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByRoomRow
	for rows.Next() {
		var i GetSubmissionsByRoomRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeProblemID,
			&i.LanguageID,
			&i.RoomID,
			&i.CodeSubmitted,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.SubmittedAt,
			&i.ProblemTitle,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByStatus = `-- name: GetSubmissionsByStatus :many
SELECT s.id, s.user_id, s.code_problem_id, s.language_id, s.room_id, s.code_submitted, s.status, s.execution_time_ms, s.submitted_at, cp.title as problem_title, l.name as language_name
FROM submissions s
JOIN code_problems cp ON s.code_problem_id = cp.id
JOIN languages l ON s.language_id = l.id
WHERE s.status = $1
ORDER BY s.submitted_at DESC
`

type GetSubmissionsByStatusRow struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	CodeProblemID   pgtype.UUID
	LanguageID      pgtype.UUID
	RoomID          pgtype.UUID
	CodeSubmitted   string
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
	SubmittedAt     pgtype.Timestamptz
	ProblemTitle    string
	LanguageName    string
}

func (q *Queries) GetSubmissionsByStatus(ctx context.Context, status SubmissionStatus) ([]GetSubmissionsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByStatusRow
	for rows.Next() {
		var i GetSubmissionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeProblemID,
			&i.LanguageID,
			&i.RoomID,
			&i.CodeSubmitted,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.SubmittedAt,
			&i.ProblemTitle,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByUser = `-- name: GetSubmissionsByUser :many
SELECT s.id, s.user_id, s.code_problem_id, s.language_id, s.room_id, s.code_submitted, s.status, s.execution_time_ms, s.submitted_at, cp.title as problem_title, l.name as language_name
FROM submissions s
JOIN code_problems cp ON s.code_problem_id = cp.id
JOIN languages l ON s.language_id = l.id
WHERE s.user_id = $1
ORDER BY s.submitted_at DESC
LIMIT $2
OFFSET $3
`

type GetSubmissionsByUserParams struct {
	UserID pgtype.UUID
	Limit  int32
	Offset int32
}

type GetSubmissionsByUserRow struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	CodeProblemID   pgtype.UUID
	LanguageID      pgtype.UUID
	RoomID          pgtype.UUID
	CodeSubmitted   string
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
	SubmittedAt     pgtype.Timestamptz
	ProblemTitle    string
	LanguageName    string
}

func (q *Queries) GetSubmissionsByUser(ctx context.Context, arg GetSubmissionsByUserParams) ([]GetSubmissionsByUserRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByUserRow
	for rows.Next() {
		var i GetSubmissionsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeProblemID,
			&i.LanguageID,
			&i.RoomID,
			&i.CodeSubmitted,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.SubmittedAt,
			&i.ProblemTitle,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, created_at FROM tags WHERE id = $1
`

func (q *Queries) GetTagByID(ctx context.Context, id pgtype.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, created_at FROM tags WHERE name = $1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const getTags = `-- name: GetTags :many
SELECT id, name, created_at FROM tags
ORDER BY name
LIMIT $1
OFFSET $2
`

type GetTagsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetTags(ctx context.Context, arg GetTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getTags, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCaseByID = `-- name: GetTestCaseByID :one
SELECT id, code_problem_id, input, expected_output, is_hidden FROM test_cases WHERE id = $1
`

func (q *Queries) GetTestCaseByID(ctx context.Context, id pgtype.UUID) (TestCase, error) {
	row := q.db.QueryRow(ctx, getTestCaseByID, id)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.CodeProblemID,
		&i.Input,
		&i.ExpectedOutput,
		&i.IsHidden,
	)
	return i, err
}

const getTestCasesByProblem = `-- name: GetTestCasesByProblem :many
SELECT id, code_problem_id, input, expected_output, is_hidden FROM test_cases
WHERE code_problem_id = $1
ORDER BY is_hidden, id
`

func (q *Queries) GetTestCasesByProblem(ctx context.Context, codeProblemID pgtype.UUID) ([]TestCase, error) {
	rows, err := q.db.Query(ctx, getTestCasesByProblem, codeProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.CodeProblemID,
			&i.Input,
			&i.ExpectedOutput,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTop3GuildsByEvent = `-- name: GetTop3GuildsByEvent :many
WITH guild_scores AS (
  SELECT
    rp.guild_id,
    SUM(rp.score) as total_score
  FROM room_players rp
  INNER JOIN rooms r ON rp.room_id = r.id
  WHERE r.event_id = $1
    AND rp.state IN ('completed'::room_player_state, 'present'::room_player_state)
  GROUP BY rp.guild_id
)
SELECT
  guild_id,
  'Guild-' || guild_id::text as guild_name,
  total_score,
  DENSE_RANK() OVER (ORDER BY total_score DESC) as rank
FROM guild_scores
ORDER BY total_score DESC
LIMIT 3
`

type GetTop3GuildsByEventRow struct {
	GuildID    pgtype.UUID
	GuildName  interface{}
	TotalScore int64
	Rank       int64
}

// Get top 3 guilds by total score for an event
// P2-1: Used to populate EventExpired message with winning guilds
func (q *Queries) GetTop3GuildsByEvent(ctx context.Context, eventID pgtype.UUID) ([]GetTop3GuildsByEventRow, error) {
	rows, err := q.db.Query(ctx, getTop3GuildsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTop3GuildsByEventRow
	for rows.Next() {
		var i GetTop3GuildsByEventRow
		if err := rows.Scan(
			&i.GuildID,
			&i.GuildName,
			&i.TotalScore,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTop3PlayersByEvent = `-- name: GetTop3PlayersByEvent :many
SELECT
  rp.user_id,
  rp.username,
  rp.score,
  rp.place as rank,
  rp.room_id
FROM room_players rp
INNER JOIN rooms r ON rp.room_id = r.id
WHERE r.event_id = $1
  AND rp.state IN ('completed'::room_player_state, 'present'::room_player_state)
ORDER BY rp.score DESC, rp.joined_at ASC
LIMIT 3
`

type GetTop3PlayersByEventRow struct {
	UserID   pgtype.UUID
	Username string
	Score    int32
	Rank     pgtype.Int4
	RoomID   pgtype.UUID
}

// Get top 3 players across all rooms in an event
// P2-1: Used to populate EventExpired message with winners
func (q *Queries) GetTop3PlayersByEvent(ctx context.Context, eventID pgtype.UUID) ([]GetTop3PlayersByEventRow, error) {
	rows, err := q.db.Query(ctx, getTop3PlayersByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTop3PlayersByEventRow
	for rows.Next() {
		var i GetTop3PlayersByEventRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Score,
			&i.Rank,
			&i.RoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSubmissionStats = `-- name: GetUserSubmissionStats :one
SELECT
    COUNT(*) as total_submissions,
    COUNT(CASE WHEN status = 'accepted' THEN 1 END) as accepted_count,
    COUNT(CASE WHEN status = 'wrong_answer' THEN 1 END) as wrong_answer_count,
    COUNT(CASE WHEN status = 'limit_exceed' THEN 1 END) as timeout_count,
    AVG(execution_time_ms) as avg_execution_time
FROM submissions
WHERE user_id = $1
`

type GetUserSubmissionStatsRow struct {
	TotalSubmissions int64
	AcceptedCount    int64
	WrongAnswerCount int64
	TimeoutCount     int64
	AvgExecutionTime float64
}

func (q *Queries) GetUserSubmissionStats(ctx context.Context, userID pgtype.UUID) (GetUserSubmissionStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserSubmissionStats, userID)
	var i GetUserSubmissionStatsRow
	err := row.Scan(
		&i.TotalSubmissions,
		&i.AcceptedCount,
		&i.WrongAnswerCount,
		&i.TimeoutCount,
		&i.AvgExecutionTime,
	)
	return i, err
}

const listEventRequests = `-- name: ListEventRequests :many
SELECT id, status, requester_guild_id, processed_by_admin_id, created_at, processed_at, event_type, title, description, proposed_start_date, proposed_end_date, notes, participation_details, room_configuration, event_specifics, rejection_reason, approved_event_id FROM event_requests
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListEventRequestsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListEventRequests(ctx context.Context, arg ListEventRequestsParams) ([]EventRequest, error) {
	rows, err := q.db.Query(ctx, listEventRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRequest
	for rows.Next() {
		var i EventRequest
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.RequesterGuildID,
			&i.ProcessedByAdminID,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.EventType,
			&i.Title,
			&i.Description,
			&i.ProposedStartDate,
			&i.ProposedEndDate,
			&i.Notes,
			&i.ParticipationDetails,
			&i.RoomConfiguration,
			&i.EventSpecifics,
			&i.RejectionReason,
			&i.ApprovedEventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventRequestsByGuild = `-- name: ListEventRequestsByGuild :many
SELECT id, status, requester_guild_id, processed_by_admin_id, created_at, processed_at, event_type, title, description, proposed_start_date, proposed_end_date, notes, participation_details, room_configuration, event_specifics, rejection_reason, approved_event_id FROM event_requests
WHERE requester_guild_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEventRequestsByGuildParams struct {
	RequesterGuildID pgtype.UUID
	Limit            int32
	Offset           int32
}

func (q *Queries) ListEventRequestsByGuild(ctx context.Context, arg ListEventRequestsByGuildParams) ([]EventRequest, error) {
	rows, err := q.db.Query(ctx, listEventRequestsByGuild, arg.RequesterGuildID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRequest
	for rows.Next() {
		var i EventRequest
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.RequesterGuildID,
			&i.ProcessedByAdminID,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.EventType,
			&i.Title,
			&i.Description,
			&i.ProposedStartDate,
			&i.ProposedEndDate,
			&i.Notes,
			&i.ParticipationDetails,
			&i.RoomConfiguration,
			&i.EventSpecifics,
			&i.RejectionReason,
			&i.ApprovedEventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventRequestsByStatus = `-- name: ListEventRequestsByStatus :many
SELECT id, status, requester_guild_id, processed_by_admin_id, created_at, processed_at, event_type, title, description, proposed_start_date, proposed_end_date, notes, participation_details, room_configuration, event_specifics, rejection_reason, approved_event_id FROM event_requests
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEventRequestsByStatusParams struct {
	Status EventRequestStatus
	Limit  int32
	Offset int32
}

func (q *Queries) ListEventRequestsByStatus(ctx context.Context, arg ListEventRequestsByStatusParams) ([]EventRequest, error) {
	rows, err := q.db.Query(ctx, listEventRequestsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRequest
	for rows.Next() {
		var i EventRequest
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.RequesterGuildID,
			&i.ProcessedByAdminID,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.EventType,
			&i.Title,
			&i.Description,
			&i.ProposedStartDate,
			&i.ProposedEndDate,
			&i.Notes,
			&i.ParticipationDetails,
			&i.RoomConfiguration,
			&i.EventSpecifics,
			&i.RejectionReason,
			&i.ApprovedEventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCodeProblem = `-- name: UpdateCodeProblem :one
UPDATE code_problems
SET title = $2, problem_statement = $3, difficulty = $4
WHERE id = $1
RETURNING id, title, problem_statement, difficulty, created_at
`

type UpdateCodeProblemParams struct {
	ID               pgtype.UUID
	Title            string
	ProblemStatement string
	Difficulty       int32
}

func (q *Queries) UpdateCodeProblem(ctx context.Context, arg UpdateCodeProblemParams) (CodeProblem, error) {
	row := q.db.QueryRow(ctx, updateCodeProblem,
		arg.ID,
		arg.Title,
		arg.ProblemStatement,
		arg.Difficulty,
	)
	var i CodeProblem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ProblemStatement,
		&i.Difficulty,
		&i.CreatedAt,
	)
	return i, err
}

const updateCodeProblemLanguageDetail = `-- name: UpdateCodeProblemLanguageDetail :one
UPDATE code_problem_language_details
SET solution_stub = $3, driver_code = $4, time_constraint_ms = $5, space_constraint_mb = $6
WHERE code_problem_id = $1 AND language_id = $2
RETURNING code_problem_id, language_id, solution_stub, driver_code, time_constraint_ms, space_constraint_mb
`

type UpdateCodeProblemLanguageDetailParams struct {
	CodeProblemID     pgtype.UUID
	LanguageID        pgtype.UUID
	SolutionStub      string
	DriverCode        string
	TimeConstraintMs  int32
	SpaceConstraintMb int32
}

func (q *Queries) UpdateCodeProblemLanguageDetail(ctx context.Context, arg UpdateCodeProblemLanguageDetailParams) (CodeProblemLanguageDetail, error) {
	row := q.db.QueryRow(ctx, updateCodeProblemLanguageDetail,
		arg.CodeProblemID,
		arg.LanguageID,
		arg.SolutionStub,
		arg.DriverCode,
		arg.TimeConstraintMs,
		arg.SpaceConstraintMb,
	)
	var i CodeProblemLanguageDetail
	err := row.Scan(
		&i.CodeProblemID,
		&i.LanguageID,
		&i.SolutionStub,
		&i.DriverCode,
		&i.TimeConstraintMs,
		&i.SpaceConstraintMb,
	)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET
  title = $2,
  description = $3,
  type = $4,
  started_date = $5,
  end_date = $6,
  max_guilds = $7,
  max_players_per_guild = $8,
  number_of_rooms = $9,
  guilds_per_room = $10,
  room_naming_prefix = $11
WHERE id = $1
RETURNING id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date
`

type UpdateEventParams struct {
	ID                 pgtype.UUID
	Title              string
	Description        string
	Type               EventType
	StartedDate        pgtype.Timestamptz
	EndDate            pgtype.Timestamptz
	MaxGuilds          pgtype.Int4
	MaxPlayersPerGuild pgtype.Int4
	NumberOfRooms      pgtype.Int4
	GuildsPerRoom      pgtype.Int4
	RoomNamingPrefix   pgtype.Text
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.StartedDate,
		arg.EndDate,
		arg.MaxGuilds,
		arg.MaxPlayersPerGuild,
		arg.NumberOfRooms,
		arg.GuildsPerRoom,
		arg.RoomNamingPrefix,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartedDate,
		&i.EndDate,
		&i.MaxGuilds,
		&i.MaxPlayersPerGuild,
		&i.NumberOfRooms,
		&i.GuildsPerRoom,
		&i.RoomNamingPrefix,
		&i.OriginalRequestID,
		&i.Status,
		&i.AssignmentDate,
	)
	return i, err
}

const updateEventCodeProblemScore = `-- name: UpdateEventCodeProblemScore :one
UPDATE event_code_problems
SET score = $3
WHERE event_id = $1 AND code_problem_id = $2
RETURNING event_id, code_problem_id, score
`

type UpdateEventCodeProblemScoreParams struct {
	EventID       pgtype.UUID
	CodeProblemID pgtype.UUID
	Score         int32
}

func (q *Queries) UpdateEventCodeProblemScore(ctx context.Context, arg UpdateEventCodeProblemScoreParams) (EventCodeProblem, error) {
	row := q.db.QueryRow(ctx, updateEventCodeProblemScore, arg.EventID, arg.CodeProblemID, arg.Score)
	var i EventCodeProblem
	err := row.Scan(&i.EventID, &i.CodeProblemID, &i.Score)
	return i, err
}

const updateEventGuildParticipantRoom = `-- name: UpdateEventGuildParticipantRoom :one
UPDATE event_guild_participants
SET room_id = $3
WHERE event_id = $1 AND guild_id = $2
RETURNING event_id, guild_id, joined_at, room_id
`

type UpdateEventGuildParticipantRoomParams struct {
	EventID pgtype.UUID
	GuildID pgtype.UUID
	RoomID  pgtype.UUID
}

func (q *Queries) UpdateEventGuildParticipantRoom(ctx context.Context, arg UpdateEventGuildParticipantRoomParams) (EventGuildParticipant, error) {
	row := q.db.QueryRow(ctx, updateEventGuildParticipantRoom, arg.EventID, arg.GuildID, arg.RoomID)
	var i EventGuildParticipant
	err := row.Scan(
		&i.EventID,
		&i.GuildID,
		&i.JoinedAt,
		&i.RoomID,
	)
	return i, err
}

const updateEventRequestStatus = `-- name: UpdateEventRequestStatus :one
UPDATE event_requests
SET
  status = $2,
  processed_by_admin_id = $3,
  processed_at = NOW() AT TIME ZONE 'utc'
,
  rejection_reason = $4,
  approved_event_id = $5
WHERE id = $1
RETURNING id, status, requester_guild_id, processed_by_admin_id, created_at, processed_at, event_type, title, description, proposed_start_date, proposed_end_date, notes, participation_details, room_configuration, event_specifics, rejection_reason, approved_event_id
`

type UpdateEventRequestStatusParams struct {
	ID                 pgtype.UUID
	Status             EventRequestStatus
	ProcessedByAdminID pgtype.UUID
	RejectionReason    pgtype.Text
	ApprovedEventID    pgtype.UUID
}

func (q *Queries) UpdateEventRequestStatus(ctx context.Context, arg UpdateEventRequestStatusParams) (EventRequest, error) {
	row := q.db.QueryRow(ctx, updateEventRequestStatus,
		arg.ID,
		arg.Status,
		arg.ProcessedByAdminID,
		arg.RejectionReason,
		arg.ApprovedEventID,
	)
	var i EventRequest
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.RequesterGuildID,
		&i.ProcessedByAdminID,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.EventType,
		&i.Title,
		&i.Description,
		&i.ProposedStartDate,
		&i.ProposedEndDate,
		&i.Notes,
		&i.ParticipationDetails,
		&i.RoomConfiguration,
		&i.EventSpecifics,
		&i.RejectionReason,
		&i.ApprovedEventID,
	)
	return i, err
}

const updateEventStatusToActive = `-- name: UpdateEventStatusToActive :one
UPDATE events
SET status = 'active'
WHERE id = $1 AND status = 'pending'
RETURNING id, title, description, type, started_date, end_date, max_guilds, max_players_per_guild, number_of_rooms, guilds_per_room, room_naming_prefix, original_request_id, status, assignment_date
`

// Atomically mark event as 'active' and prevent duplicate processing
// Only updates if the event is still in 'pending' status
// Returns the updated event if successful, or error if already processed
func (q *Queries) UpdateEventStatusToActive(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventStatusToActive, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartedDate,
		&i.EndDate,
		&i.MaxGuilds,
		&i.MaxPlayersPerGuild,
		&i.NumberOfRooms,
		&i.GuildsPerRoom,
		&i.RoomNamingPrefix,
		&i.OriginalRequestID,
		&i.Status,
		&i.AssignmentDate,
	)
	return i, err
}

const updateEventStatusToCompleted = `-- name: UpdateEventStatusToCompleted :execrows
UPDATE events
SET status = 'completed'
WHERE id = $1 AND status = 'active'
`

// Atomically mark event as 'completed' (only if still 'active')
// Used by event expiry timer - atomic update prevents duplicate completion
// Returns number of rows affected (1 = success, 0 = already completed)
func (q *Queries) UpdateEventStatusToCompleted(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, updateEventStatusToCompleted, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateGuildLeaderboardEntry = `-- name: UpdateGuildLeaderboardEntry :one
UPDATE guild_leaderboard_entries
SET rank = $2, total_score = $3
WHERE id = $1
RETURNING id, guild_id, guild_name, event_id, rank, total_score, snapshot_date
`

type UpdateGuildLeaderboardEntryParams struct {
	ID         pgtype.UUID
	Rank       int32
	TotalScore int32
}

func (q *Queries) UpdateGuildLeaderboardEntry(ctx context.Context, arg UpdateGuildLeaderboardEntryParams) (GuildLeaderboardEntry, error) {
	row := q.db.QueryRow(ctx, updateGuildLeaderboardEntry, arg.ID, arg.Rank, arg.TotalScore)
	var i GuildLeaderboardEntry
	err := row.Scan(
		&i.ID,
		&i.GuildID,
		&i.GuildName,
		&i.EventID,
		&i.Rank,
		&i.TotalScore,
		&i.SnapshotDate,
	)
	return i, err
}

const updateLanguage = `-- name: UpdateLanguage :one
UPDATE languages
SET name = $2, compile_cmd = $3, run_cmd = $4, temp_file_dir = $5, temp_file_name = $6
WHERE id = $1
RETURNING id, name, compile_cmd, run_cmd, temp_file_dir, temp_file_name
`

type UpdateLanguageParams struct {
	ID           pgtype.UUID
	Name         string
	CompileCmd   string
	RunCmd       string
	TempFileDir  pgtype.Text
	TempFileName pgtype.Text
}

func (q *Queries) UpdateLanguage(ctx context.Context, arg UpdateLanguageParams) (Language, error) {
	row := q.db.QueryRow(ctx, updateLanguage,
		arg.ID,
		arg.Name,
		arg.CompileCmd,
		arg.RunCmd,
		arg.TempFileDir,
		arg.TempFileName,
	)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompileCmd,
		&i.RunCmd,
		&i.TempFileDir,
		&i.TempFileName,
	)
	return i, err
}

const updateLeaderboardEntry = `-- name: UpdateLeaderboardEntry :one
UPDATE leaderboard_entries
SET rank = $2, score = $3
WHERE id = $1
RETURNING id, user_id, username, event_id, rank, score, snapshot_date
`

type UpdateLeaderboardEntryParams struct {
	ID    pgtype.UUID
	Rank  int32
	Score int32
}

func (q *Queries) UpdateLeaderboardEntry(ctx context.Context, arg UpdateLeaderboardEntryParams) (LeaderboardEntry, error) {
	row := q.db.QueryRow(ctx, updateLeaderboardEntry, arg.ID, arg.Rank, arg.Score)
	var i LeaderboardEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.EventID,
		&i.Rank,
		&i.Score,
		&i.SnapshotDate,
	)
	return i, err
}

const updateRoom = `-- name: UpdateRoom :one
UPDATE rooms
SET name = $2, description = $3
WHERE id = $1
RETURNING id, event_id, name, description, created_date
`

type UpdateRoomParams struct {
	ID          pgtype.UUID
	Name        string
	Description string
}

func (q *Queries) UpdateRoom(ctx context.Context, arg UpdateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, updateRoom, arg.ID, arg.Name, arg.Description)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.CreatedDate,
	)
	return i, err
}

const updateRoomPlayerScore = `-- name: UpdateRoomPlayerScore :one
UPDATE room_players
SET score = $3, place = $4
WHERE room_id = $1 AND user_id = $2
RETURNING room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at
`

type UpdateRoomPlayerScoreParams struct {
	RoomID pgtype.UUID
	UserID pgtype.UUID
	Score  int32
	Place  pgtype.Int4
}

func (q *Queries) UpdateRoomPlayerScore(ctx context.Context, arg UpdateRoomPlayerScoreParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, updateRoomPlayerScore,
		arg.RoomID,
		arg.UserID,
		arg.Score,
		arg.Place,
	)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.UserID,
		&i.GuildID,
		&i.Username,
		&i.Score,
		&i.Place,
		&i.State,
		&i.DisconnectedAt,
		&i.JoinedAt,
	)
	return i, err
}

const updateRoomPlayerState = `-- name: UpdateRoomPlayerState :one
UPDATE room_players
SET state = $3
WHERE room_id = $1 AND user_id = $2
RETURNING room_id, user_id, guild_id, username, score, place, state, disconnected_at, joined_at
`

type UpdateRoomPlayerStateParams struct {
	RoomID pgtype.UUID
	UserID pgtype.UUID
	State  RoomPlayerState
}

func (q *Queries) UpdateRoomPlayerState(ctx context.Context, arg UpdateRoomPlayerStateParams) (RoomPlayer, error) {
	row := q.db.QueryRow(ctx, updateRoomPlayerState, arg.RoomID, arg.UserID, arg.State)
	var i RoomPlayer
	err := row.Scan(
		&i.RoomID,
		&i.UserID,
		&i.GuildID,
		&i.Username,
		&i.Score,
		&i.Place,
		&i.State,
		&i.DisconnectedAt,
		&i.JoinedAt,
	)
	return i, err
}

const updateRoomPlayerStatesOnEventComplete = `-- name: UpdateRoomPlayerStatesOnEventComplete :execrows
WITH locked_players AS (
  SELECT rp.room_id, rp.user_id, rp.state
  FROM room_players rp
  INNER JOIN rooms r ON rp.room_id = r.id
  WHERE r.event_id = $1
  FOR UPDATE OF rp
)
UPDATE room_players rp
SET state = CASE
  WHEN lp.state = 'present' THEN 'completed'::room_player_state
  WHEN lp.state = 'disconnected' THEN 'left'::room_player_state
  ELSE lp.state
END
FROM locked_players lp
WHERE rp.room_id = lp.room_id AND rp.user_id = lp.user_id
`

// Update player states when event completes
// Uses FOR UPDATE to lock rows and prevent race conditions
// present -> completed (player was active when event ended)
// disconnected -> left (player disconnected during event)
// Returns number of rows affected
func (q *Queries) UpdateRoomPlayerStatesOnEventComplete(ctx context.Context, eventID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, updateRoomPlayerStatesOnEventComplete, eventID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSubmission = `-- name: UpdateSubmission :one
UPDATE submissions
SET status = $2, execution_time_ms = $3
WHERE id = $1
RETURNING id, user_id, code_problem_id, language_id, room_id, code_submitted, status, execution_time_ms, submitted_at
`

type UpdateSubmissionParams struct {
	ID              pgtype.UUID
	Status          SubmissionStatus
	ExecutionTimeMs pgtype.Int4
}

func (q *Queries) UpdateSubmission(ctx context.Context, arg UpdateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, updateSubmission, arg.ID, arg.Status, arg.ExecutionTimeMs)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CodeProblemID,
		&i.LanguageID,
		&i.RoomID,
		&i.CodeSubmitted,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.SubmittedAt,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = $2
WHERE id = $1
RETURNING id, name, created_at
`

type UpdateTagParams struct {
	ID   pgtype.UUID
	Name string
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, updateTag, arg.ID, arg.Name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const updateTestCase = `-- name: UpdateTestCase :one
UPDATE test_cases
SET input = $2, expected_output = $3, is_hidden = $4
WHERE id = $1
RETURNING id, code_problem_id, input, expected_output, is_hidden
`

type UpdateTestCaseParams struct {
	ID             pgtype.UUID
	Input          string
	ExpectedOutput string
	IsHidden       bool
}

func (q *Queries) UpdateTestCase(ctx context.Context, arg UpdateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, updateTestCase,
		arg.ID,
		arg.Input,
		arg.ExpectedOutput,
		arg.IsHidden,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.CodeProblemID,
		&i.Input,
		&i.ExpectedOutput,
		&i.IsHidden,
	)
	return i, err
}
